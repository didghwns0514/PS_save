# 프로그래머스 -카카오 인턴십 - 경주로건설

- 문제

- 소요시간

- 주의

- 발상

- 코드

```python
import heapq

def make_price(pos_srt, pos_end):
    if pos_srt == None or pos_end == None:
        return 100
    else:
        y_srt, x_srt = pos_srt
        y_end, x_end = pos_end
        if (y_srt - y_end)*(x_srt - x_end) :
            return 600
        else:
            return 100
        

def dijkstra(start, graph):
    
    history = {}
    q = []
    q_corner = []
    
    dx = [1, 0, -1, 0]
    dy = [0, -1, 0, 1]
    MAX_X = len(graph[0])
    MAX_Y = len(graph)
    
    for i_y, y in enumerate(graph):
        for i_x, x in enumerate(y):
            history[(i_y, i_x)] = float('inf')
            
    history[start] = 0
    heapq.heappush(q, [start, history[start]])
    q_corner.insert(len(q_corner), start)
    
    while q:
        print(f'q : {q}')
        tmp_corner = None
        p_pos, p_his = heapq.heappop(q)

        if len(q_corner) == 2:
            tmp_corner = q_corner.pop(0)    
        q_corner.insert(len(q_corner), p_pos)
        
        
        if history[p_pos] > p_his:
            continue
        
        for i in range(4):
            tmp_x = p_pos[1] + dx[i]
            tmp_y = p_pos[0] + dy[i]
            print(f'tmp_x : {tmp_x}, tmp_y : {tmp_y}')
            if ((tmp_y >= 0 and tmp_y < MAX_Y) and (tmp_x >= 0 and tmp_x < MAX_X)):
                if graph[tmp_y][tmp_x] != 1:
                    targ_dist, targ_pos = make_price(tmp_corner, (tmp_y, tmp_x)), (tmp_y, tmp_x)
                    print(f'targ_dist : {targ_dist}, targ_pos : {targ_pos}')

                    total_dist = targ_dist + p_his
                    print(f'targ_dist : {targ_dist} + p_his : {p_his} = total_dist : {total_dist}')
                    print(f'targ_pos : {targ_pos}, history[targ_pos] : {history[targ_pos]}')
                    if total_dist < history[targ_pos]:
                        history[targ_pos] = total_dist
                        heapq.heappush(q, [targ_pos, total_dist])
        
        print(f'history : {history}')
        print(f'')
    
    return history

def solution(board):

    return dijkstra((0,0), board)[(len(board)-1, len(board)-1)]
```